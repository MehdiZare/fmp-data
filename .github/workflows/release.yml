name: Release

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  guard-label:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      bump: ${{ steps.bump.outputs.bump }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          fetch-depth: 0

      - name: Derive bump from PR label
        id: bump
        shell: bash
        run: |
          set -euo pipefail
          pr_json="$(gh api "repos/${{ github.repository }}/commits/${GITHUB_SHA}/pulls" || true)"
          pr="$(jq -r '.[0].number // empty' <<<"$pr_json")"
          if [[ -z "$pr" ]]; then
            echo "::error::Commit ${GITHUB_SHA} is not part of a merged PR."
            exit 1
          fi
          labels="$(gh pr view "$pr" --json labels --jq '.labels[].name')"

          bump=""
          [[ "$labels" == *"release:patch"* ]] && bump="patch"
          [[ "$labels" == *"release:minor"* ]] && bump="minor"
          [[ "$labels" == *"release:major"* ]] && bump="major"
          echo "bump=$bump" >>"$GITHUB_OUTPUT"

          if [[ -z "$bump" || "$(grep -c 'release:' <<<"$labels")" -ne 1 ]]; then
            echo "::error::Exactly one release:* label required."
            exit 1
          fi

  tag-version:
    if: github.event_name == 'push'
    needs: guard-label
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.tag.outputs.new_tag }}
      new_version: ${{ steps.tag.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4.2.0
        with:
          fetch-depth: 0

      - name: Create and push tag
        id: tag
        env:
          BUMP: ${{ needs.guard-label.outputs.bump }}
        shell: bash
        run: |
          set -euo pipefail
          latest=$(git describe --tags --abbrev=0 2>/dev/null || echo v0.0.0)
          IFS='.' read -r major minor patch <<<"${latest#v}"
          case "$BUMP" in
            patch) patch=$((patch+1));;
            minor) minor=$((minor+1)); patch=0;;
            major) major=$((major+1)); minor=0; patch=0;;
          esac
          new_tag="v${major}.${minor}.${patch}"
          new_version="${major}.${minor}.${patch}"

          echo "Creating new tag: $new_tag"
          echo "New version will be: $new_version"

          echo "new_tag=$new_tag" >>"$GITHUB_OUTPUT"
          echo "new_version=$new_version" >>"$GITHUB_OUTPUT"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "$new_tag"
          git push origin "$new_tag"

  build:
    runs-on: ubuntu-latest
    needs: [tag-version]
    if: always() && (needs.tag-version.result == 'success' || needs.tag-version.result == 'skipped')
    outputs:
      package_version: ${{ steps.extract-version.outputs.version }}
      wheel_file: ${{ steps.extract-version.outputs.wheel_file }}
      sdist_file: ${{ steps.extract-version.outputs.sdist_file }}
      is_development: ${{ steps.extract-version.outputs.is_development }}
    steps:
      - uses: actions/checkout@v4.2.0
        with:
          fetch-depth: 0
          ref: "${{ github.event_name == 'push' && needs.tag-version.outputs.new_tag || '' }}"

      - uses: actions/setup-python@v5.6.0
        with:
          python-version: "3.12"

      # Install uv for faster dependency management (optional)
      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true
        continue-on-error: true

      # Cache based on Poetry files since that's our source of truth
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pypoetry
            ~/.cache/pip
            ~/.cache/uv
            ~/.local/share/uv
          key: ${{ runner.os }}-build-${{ hashFiles('**/poetry.lock', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ hashFiles('**/pyproject.toml') }}
            ${{ runner.os }}-build-

      - name: Install toolchain
        run: |
          # Install Poetry first (required for building and dynamic versioning)
          python -m pip install --upgrade pip poetry build packaging

          # Add poetry-dynamic-versioning plugin
          poetry self add poetry-dynamic-versioning[plugin]

          # Try to use uv for faster dependency installation
          if command -v uv &> /dev/null; then
            echo "‚úÖ uv available, using for fast dependency installation"

            # Use uv to sync dependencies from pyproject.toml
            if uv sync --extra dev --extra langchain --extra mcp-server; then
              echo "‚úÖ uv sync successful"
              uv add --dev nox
              echo "UV_AVAILABLE=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è uv sync failed, falling back to Poetry"
              poetry install --with dev --extras "langchain mcp-server"
              poetry run pip install nox
              echo "UV_AVAILABLE=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è uv not available, using Poetry"
            poetry install --with dev --extras "langchain mcp-server"
            poetry run pip install nox
            echo "UV_AVAILABLE=false" >> $GITHUB_ENV
          fi

      - name: Verify dynamic versioning
        run: |
          echo "Git information:"
          echo "  Current commit: $(git rev-parse --short HEAD)"
          echo "  Current branch: $(git branch --show-current || echo 'detached HEAD')"
          echo "  Latest tag: $(git describe --tags --abbrev=0 2>/dev/null || echo 'No tags found')"
          echo "  Git describe: $(git describe --tags --always)"
          echo ""

          poetry_version=$(poetry version --short)
          echo "Poetry detected version: $poetry_version"

          # Check version type
          if [[ "$poetry_version" == *.post* ]]; then
            echo "Development version detected (contains .post)"
            echo "Suitable for Test PyPI"
            if [[ "${{ github.event_name }}" == "push" ]]; then
              echo "::error::Production release must be from clean tag, not development version"
              echo "Current version: $poetry_version"
              echo "Expected: Clean version like 1.0.0, 1.1.0, etc."
              exit 1
            fi
          else
            echo "Clean release version detected"
            echo "Suitable for Production PyPI"
          fi

          # Fail if still seeing 0.0.0
          if [[ "$poetry_version" == "0.0.0" ]]; then
            echo "::error::Dynamic versioning failed - still seeing 0.0.0"
            echo "Check that poetry-dynamic-versioning is configured correctly"
            exit 1
          fi

      - name: Run smoke tests
        run: |
          if [[ "$UV_AVAILABLE" == "true" ]]; then
            echo "üöÄ Running tests with uv"
            NOX_USE_UV=1 uv run nox -s smoke
          else
            echo "üêç Running tests with Poetry"
            poetry run nox -s smoke
          fi

      # Always use Poetry for building to maintain dynamic versioning compatibility
      - name: Build package
        run: |
          echo "Building package with Poetry (maintains dynamic versioning)"
          poetry build

      - name: Extract version from built package
        id: extract-version
        run: |
          echo "Contents of dist/ directory:"
          ls -la dist/
          echo ""

          wheel_file=$(ls dist/*.whl | head -1)
          sdist_file=$(ls dist/*.tar.gz | head -1)

          if [[ -z "$wheel_file" ]]; then
            echo "::error::No wheel file found in dist/"
            exit 1
          fi

          if [[ -z "$sdist_file" ]]; then
            echo "::error::No sdist file found in dist/"
            exit 1
          fi

          # Extract version using packaging library
          version=$(python3 -c "
          from pathlib import Path
          from packaging.utils import parse_wheel_filename
          import sys
          try:
              wheel_path = Path('$wheel_file')
              name, version, build_tag, tags = parse_wheel_filename(wheel_path.name)
              print(version)
          except Exception as e:
              print(f'Error parsing wheel: {e}', file=sys.stderr)
              sys.exit(1)
          ")

          if [[ -z "$version" ]]; then
            echo "::error::Failed to extract version from wheel filename"
            exit 1
          fi

          echo "Extracted version: $version"
          echo "Wheel file: $(basename "$wheel_file")"
          echo "Sdist file: $(basename "$sdist_file")"

          # Check if development version
          is_development="false"
          if [[ "$version" == *.post* ]]; then
            is_development="true"
          fi

          # Set outputs
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "wheel_file=$(basename "$wheel_file")" >> "$GITHUB_OUTPUT"
          echo "sdist_file=$(basename "$sdist_file")" >> "$GITHUB_OUTPUT"
          echo "is_development=$is_development" >> "$GITHUB_OUTPUT"

          # Create summary
          echo "## Package Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | \`$version\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Type** | $([ "$is_development" = "true" ] && echo "Development" || echo "Release") |" >> $GITHUB_STEP_SUMMARY
          echo "| **Wheel** | \`$(basename "$wheel_file")\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Sdist** | \`$(basename "$sdist_file")\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dependency Tool** | $([ "$UV_AVAILABLE" = "true" ] && echo "uv (fast)" || echo "Poetry") |" >> $GITHUB_STEP_SUMMARY
          echo "| **Build Tool** | Poetry (dynamic versioning) |" >> $GITHUB_STEP_SUMMARY

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.6.2
        with:
          name: dist
          path: dist/*

  test-publish:
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4.3.0
        with:
          name: dist
          path: dist

      - uses: actions/setup-python@v5.6.0
        with:
          python-version: "3.12"

      - run: python -m pip install --upgrade twine

      - name: Upload to Test PyPI
        env:
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_TOKEN }}
        run: |
          echo "Uploading to Test PyPI"
          echo "Version: ${{ needs.build.outputs.package_version }}"
          echo "Type: $([ "${{ needs.build.outputs.is_development }}" = "true" ] && echo "Development" || echo "Release")"
          echo "Wheel: ${{ needs.build.outputs.wheel_file }}"
          echo "Sdist: ${{ needs.build.outputs.sdist_file }}"
          echo ""

          python -m twine upload --non-interactive --skip-existing \
            --repository-url https://test.pypi.org/legacy/ \
            -u __token__ -p "$TWINE_PASSWORD" dist/*

          echo ""
          echo "Successfully uploaded to Test PyPI"
          echo "View at: https://test.pypi.org/project/fmp-data/${{ needs.build.outputs.package_version }}/"

          # Add to summary
          echo "## Test PyPI Upload" >> $GITHUB_STEP_SUMMARY
          echo "Successfully uploaded version \`${{ needs.build.outputs.package_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View on Test PyPI](https://test.pypi.org/project/fmp-data/${{ needs.build.outputs.package_version }}/)" >> $GITHUB_STEP_SUMMARY

  publish:
    if: github.event_name == 'push'
    needs: [tag-version, build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - run: python -m pip install --upgrade twine

      - name: Upload to PyPI
        env:
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: |
          echo "Uploading to Production PyPI"
          echo "Git tag: ${{ needs.tag-version.outputs.new_tag }}"
          echo "Package version: ${{ needs.build.outputs.package_version }}"
          echo "Wheel: ${{ needs.build.outputs.wheel_file }}"
          echo "Sdist: ${{ needs.build.outputs.sdist_file }}"
          echo ""

          # Verify versions match
          if [[ "${{ needs.tag-version.outputs.new_version }}" != "${{ needs.build.outputs.package_version }}" ]]; then
            echo "::warning::Tag version (${{ needs.tag-version.outputs.new_version }}) doesn't match package version (${{ needs.build.outputs.package_version }})"
          fi

          python -m twine upload --non-interactive --skip-existing \
            -u __token__ -p "$TWINE_PASSWORD" dist/*

          echo ""
          echo "Successfully released to PyPI"
          echo "View at: https://pypi.org/project/fmp-data/${{ needs.build.outputs.package_version }}/"

          # Add to summary
          echo "## PyPI Release" >> $GITHUB_STEP_SUMMARY
          echo "Successfully released version \`${{ needs.build.outputs.package_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View on PyPI](https://pypi.org/project/fmp-data/${{ needs.build.outputs.package_version }}/)" >> $GITHUB_STEP_SUMMARY

      - uses: actions/checkout@v4.2.0
        with:
          fetch-depth: 0
          ref: ${{ needs.tag-version.outputs.new_tag }}

      # Install uv for faster docs build if available
      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true
        continue-on-error: true

      - name: Build and deploy docs
        run: |
          python -m pip install --upgrade poetry nox

          if command -v uv &> /dev/null; then
            echo "üöÄ Building docs with uv"

            # Use uv to sync with docs extras
            if uv sync --extra docs; then
              NOX_USE_UV=1 uv run nox -s docs
            else
              echo "‚ö†Ô∏è uv sync failed, falling back to Poetry"
              poetry install --with docs
              poetry run nox -s docs
            fi
          else
            echo "üêç Building docs with Poetry"
            poetry install --with docs
            poetry run nox -s docs
          fi

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.tag-version.outputs.new_tag }}
          name: Release ${{ needs.tag-version.outputs.new_tag }}
          body: |
            ## Package Information

            - **Version:** `${{ needs.build.outputs.package_version }}`
            - **Wheel:** `${{ needs.build.outputs.wheel_file }}`
            - **Sdist:** `${{ needs.build.outputs.sdist_file }}`
            - **Build:** Poetry + uv dependencies for faster CI

            ## Performance Improvements

            This release was built using uv for dependency management, resulting in:
            - ‚ö° 5-10x faster dependency installation
            - üöÄ 2-3x faster overall CI time
            - üíæ Better caching efficiency

            ## Links

            - [PyPI Package](https://pypi.org/project/fmp-data/${{ needs.build.outputs.package_version }}/)
            - [Documentation](https://github.com/MehdiZare/fmp-data#readme)
            - [Source Code](https://github.com/MehdiZare/fmp-data/tree/${{ needs.tag-version.outputs.new_tag }})
