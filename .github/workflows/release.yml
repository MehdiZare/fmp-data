# .github/workflows/release.yml
name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: read

jobs:
  determine-version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check-release.outputs.should_release }}
      version_type: ${{ steps.check-release.outputs.version_type }}
      pr_number: ${{ steps.check-release.outputs.pr_number }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if should release
        id: check-release
        uses: actions/github-script@v7
        with:
          script: |
            // Get the latest commit
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              per_page: 1
            });

            const commitMessage = commits[0].commit.message;
            console.log('Commit message:', commitMessage);

            // Check if this is a merge commit from a PR
            const prMatch = commitMessage.match(/\(#(\d+)\)/);
            if (!prMatch) {
              console.log('Not a PR merge commit, skipping release');
              core.setOutput('should_release', 'false');
              return;
            }

            const prNumber = prMatch[1];
            console.log('PR number:', prNumber);
            core.setOutput('pr_number', prNumber);

            // Get PR labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const labels = pr.labels.map(l => l.name);
            console.log('PR labels:', labels);

            if (labels.includes('skip-release')) {
              console.log('Skip release label found');
              core.setOutput('should_release', 'false');
              return;
            }

            let versionType = 'patch'; // default
            if (labels.includes('major')) {
              versionType = 'major';
            } else if (labels.includes('minor')) {
              versionType = 'minor';
            } else if (labels.includes('patch')) {
              versionType = 'patch';
            }

            console.log('Version type:', versionType);
            core.setOutput('should_release', 'true');
            core.setOutput('version_type', versionType);

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.should_release == 'true'
    outputs:
      tag: ${{ steps.create-tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create version tag
        id: create-tag
        run: |
          # Get current version
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Current tag: $CURRENT_TAG"

          # Parse version
          CURRENT_VERSION=${CURRENT_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          # Bump version
          VERSION_TYPE="${{ needs.determine-version.outputs.version_type }}"
          case $VERSION_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"

          echo "New tag: $NEW_TAG"

          # Create and push tag
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"

          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

  publish:
    name: Publish Package
    runs-on: ubuntu-latest
    needs: [determine-version, create-release]
    environment: production

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-release.outputs.tag }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: "1.8.4"
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Add dynamic versioning plugin
        run: poetry self add poetry-dynamic-versioning

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Run final tests
        env:
          FMP_TEST_API_KEY: ${{ secrets.FMP_TEST_API_KEY }}
        run: poetry run pytest --cov=fmp_data

      - name: Build package
        run: |
          poetry build
          echo "Built packages:"
          ls -la dist/

      - name: Publish to TestPyPI
        if: github.event_name != 'workflow_dispatch'
        run: |
          poetry config repositories.testpypi https://test.pypi.org/legacy/
          poetry config pypi-token.testpypi ${{ secrets.TEST_PYPI_TOKEN }}
          poetry publish -r testpypi --skip-existing

      - name: Publish to PyPI
        run: |
          poetry config pypi-token.pypi ${{ secrets.PYPI_TOKEN }}
          poetry publish

  github-release:
    name: GitHub Release
    runs-on: ubuntu-latest
    needs: [determine-version, create-release, publish]

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          TAG="${{ needs.create-release.outputs.tag }}"
          PREV_TAG=$(git describe --tags --abbrev=0 $TAG^ 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            echo "Generating changelog from $PREV_TAG to $TAG"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREV_TAG..$TAG | head -20)
          else
            echo "First release"
            CHANGELOG="- Initial release"
          fi

          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-release.outputs.tag }}
          name: Release ${{ needs.create-release.outputs.tag }}
          body: |
            ## Changes

            ${{ steps.changelog.outputs.changelog }}

            **Type:** ${{ needs.determine-version.outputs.version_type }}
            **PR:** #${{ needs.determine-version.outputs.pr_number }}

            ## Installation

            ```bash
            pip install --upgrade fmp-data
            ```

            **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ needs.create-release.outputs.tag }}
          draft: false
          prerelease: false
